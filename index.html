<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>FINAL ASCII PRO</title>
    <style>
        body { margin: 0; background: #000; overflow: hidden; display: flex; flex-direction: column; align-items: center; justify-content: center; height: 100vh; }
        canvas { width: 100vw; height: 100vh; object-fit: cover; background: #000; }
        .controls { position: fixed; bottom: 30px; z-index: 100; display: flex; gap: 10px; }
        button { background: rgba(40, 40, 40, 0.9); color: #fff; border: 1px solid #666; padding: 15px 20px; border-radius: 30px; font-family: monospace; font-size: 14px; font-weight: bold; }
        video { display: none; }
    </style>
</head>
<body>

    <canvas id="output"></canvas>
    <video id="video" autoplay playsinline muted></video>

    <div class="controls">
        <button id="flip">SWITCH CAM</button>
        <button id="color">MODE: FULL</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('output');
        const ctx = canvas.getContext('2d', { alpha: false });

        // --- Optimized High Density ---
        const COLS = 150; // High density but safer for mobile CPUs
        const ROWS = 120; // Maintain rectangular 4:3-ish aspect
        const CHARS = "$@B%8&WM#*oahkbdpqwmZO0QLCJUYXzcvunxrjft/\\|()1{}[]?-_+~<>i!lI;:,\"^`'. ";
        
        let facingMode = "environment";
        let colorMode = 0; // 0: Full, 1: Green, 2: Blue, 3: Gray
        const modes = ["FULL", "GREEN", "BLUE", "GRAY"];

        async function start() {
            if (window.stream) window.stream.getTracks().forEach(t => t.stop());
            try {
                const s = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: facingMode, width: 640, height: 480 }
                });
                window.stream = s;
                video.srcObject = s;
                video.play();
            } catch (e) {
                alert("Please use HTTPS and allow camera access.");
            }
        }

        function render() {
            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                // Adjust internal canvas to match screen resolution
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;

                const cellW = canvas.width / COLS;
                const cellH = canvas.height / ROWS;

                // Hidden tiny canvas for data sampling
                const offscreen = document.createElement('canvas');
                offscreen.width = COLS;
                offscreen.height = ROWS;
                const oCtx = offscreen.getContext('2d');
                
                // Draw flipped for front cam
                if (facingMode === "user") {
                    oCtx.translate(COLS, 0);
                    oCtx.scale(-1, 1);
                }
                oCtx.drawImage(video, 0, 0, COLS, ROWS);
                const pixels = oCtx.getImageData(0, 0, COLS, ROWS).data;

                // Clear background
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Font setup
                ctx.font = `${cellH}px monospace`;
                ctx.textAlign = "center";

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        const i = (y * COLS + x) * 4;
                        const r = pixels[i];
                        const g = pixels[i+1];
                        const b = pixels[i+2];
                        const brightness = (r + g + b) / 3;
                        
                        const char = CHARS[Math.floor((brightness / 256) * CHARS.length)];

                        // Apply color filter
                        if (colorMode === 0) ctx.fillStyle = `rgb(${r},${g},${b})`;
                        else if (colorMode === 1) ctx.fillStyle = `rgb(0,${brightness},0)`;
                        else if (colorMode === 2) ctx.fillStyle = `rgb(0,${brightness/2},${brightness})`;
                        else ctx.fillStyle = `rgb(${brightness},${brightness},${brightness})`;

                        ctx.fillText(char, x * cellW + cellW/2, y * cellH + cellH);
                    }
                }
            }
            requestAnimationFrame(render);
        }

        document.getElementById('flip').onclick = () => {
            facingMode = facingMode === "environment" ? "user" : "environment";
            start();
        };

        document.getElementById('color').onclick = () => {
            colorMode = (colorMode + 1) % modes.length;
            document.getElementById('color').innerText = "MODE: " + modes[colorMode];
        };

        start().then(() => requestAnimationFrame(render));
    </script>
</body>
</html>
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            return shader;
        }

        const program = gl.createProgram();
        gl.attachShader(program, createShader(gl, gl.VERTEX_SHADER, vsSource));
        gl.attachShader(program, createShader(gl, gl.FRAGMENT_SHADER, fsSource));
        gl.linkProgram(program);
        gl.useProgram(program);

        const posBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1,1, 1,1, -1,-1, 1,-1]), gl.STATIC_DRAW);

        const posAttrib = gl.getAttribLocation(program, "aVertexPosition");
        gl.enableVertexAttribArray(posAttrib);
        gl.vertexAttribPointer(posAttrib, 2, gl.FLOAT, false, 0, 0);

        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);

        const uCols = gl.getUniformLocation(program, "uCols");
        const uRows = gl.getUniformLocation(program, "uRows");
        const uMode = gl.getUniformLocation(program, "uColorMode");

        function draw() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            gl.viewport(0, 0, canvas.width, canvas.height);

            gl.bindTexture(gl.TEXTURE_2D, texture);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);
            
            gl.uniform1f(uCols, COLS);
            gl.uniform1f(uRows, ROWS);
            gl.uniform1i(uMode, colorMode);

            gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            requestAnimationFrame(draw);
        }

        document.getElementById('flipBtn').onclick = () => {
            facingMode = facingMode === "environment" ? "user" : "environment";
            startCamera();
        };

        document.getElementById('modeBtn').onclick = () => {
            colorMode = (colorMode + 1) % modes.length;
            document.getElementById('modeBtn').innerText = modes[colorMode];
        };

        startCamera().then(() => requestAnimationFrame(draw));
    </script>
</body>
</html>
