<!DOCTYPE html>
<html>
<head>
  <title>Dragon Face Mapper</title>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <style>
    body { margin: 0; background: #000; overflow: hidden; color: gold; font-family: sans-serif; }
    video, canvas { position: absolute; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; }
    #ui { position: absolute; bottom: 20px; left: 20px; z-index: 10; pointer-events: none; }
  </style>
</head>
<body>
  <div id="ui"><h1>DRAGON MAPPING ACTIVE</h1><p>Align face to camera...</p></div>
  <video id="input_video"></video>
  <canvas id="output_canvas"></canvas>

<script type="module">
  const videoElement = document.getElementById('input_video');
  const canvasElement = document.getElementById('output_canvas');
  const canvasCtx = canvasElement.getContext('2d');

  function onResults(results) {
    canvasElement.width = window.innerWidth;
    canvasElement.height = window.innerHeight;
    canvasCtx.save();
    canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
    
    // 1. Mirror the video
    canvasCtx.translate(canvasElement.width, 0);
    canvasCtx.scale(-1, 1);

    if (results.multiFaceLandmarks) {
      for (const landmarks of results.multiFaceLandmarks) {
        // Draw the "Dragon Map" - Neon Green Wireframe
        canvasCtx.strokeStyle = "#39FF14"; 
        canvasCtx.lineWidth = 1;

        // Draw the skeletal mesh
        for (let i = 0; i < landmarks.length; i += 5) {
          const pt = landmarks[i];
          const x = pt.x * canvasElement.width;
          const y = pt.y * canvasElement.height;
          
          // Connect points to create a "scaly" look
          canvasCtx.beginPath();
          canvasCtx.arc(x, y, 2, 0, 2 * Math.PI);
          canvasCtx.stroke();
          
          if(i % 10 === 0) {
             canvasCtx.moveTo(x, y);
             canvasCtx.lineTo(x + (Math.random() * 20), y - (Math.random() * 20));
             canvasCtx.stroke();
          }
        }

        // Draw Dragon Eyes
        const leftEye = landmarks[159];
        const rightEye = landmarks[386];
        drawDragonEye(leftEye.x * canvasElement.width, leftEye.y * canvasElement.height);
        drawDragonEye(rightEye.x * canvasElement.width, rightEye.y * canvasElement.height);
      }
    }
    canvasCtx.restore();
  }

  function drawDragonEye(x, y) {
    canvasCtx.fillStyle = "rgba(255, 100, 0, 0.7)";
    canvasCtx.beginPath();
    canvasCtx.ellipse(x, y, 15, 25, 0, 0, Math.PI * 2);
    canvasCtx.fill();
    canvasCtx.fillStyle = "black";
    canvasCtx.fillRect(x - 2, y - 15, 4, 30); // Slit pupil
  }

  const faceMesh = new FaceMesh({locateFile: (file) => {
    return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
  }});

  faceMesh.setOptions({
    maxNumFaces: 1,
    refineLandmarks: true,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  faceMesh.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await faceMesh.send({image: videoElement});
    },
    width: 1280,
    height: 720
  });
  camera.start();
</script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</body>
</html>

